/*
 * Generic Puzzle is the main driver for the puzzle solver.  It takes an input, a goal and a puzzle type from
 * the UI.  Depending on the input puzzle type, it will pass the input and the goal to the correct puzzle library.
 * Currently, the only puzzle supported is eightPuzzle.
 */

/*
 * genericPuzzle.run() takes an input object from the UI (req).  req is expected to be an object with the following
 * format: { puzzleType: string,
 *           algorithm: string,
 *           input: string,
 *           goal: string }
 *
 * run() parses out the puzzleType and then calls [puzzle].run() on the appropriate puzzle
 * passing in the input, goal and algorithm.
 *
 * The expected return object from a puzzle is in the following format:
 * res = {
 *          error: String - Any error messages
 *          solutionTree: object - a JS object representation of the tree generated by the puzzle after a solution is found
 *       }
 */
var eightPuzzle = require('../eightPuzzle/eightPuzzleDriver');

exports.run = function (req) {
    var puzzleType, puzzle,
        puzzleInfo, puzzleOut,
        startTime, endTime,
        res;
    // initialize variables
    puzzle = '';
    res = {};
    puzzleInfo = {};
    puzzleType = req.body.puzzleType;
    puzzleInfo.algorithm = req.body.algorithm;
    puzzleInfo.input = req.body.input;
    puzzleInfo.goal = req.body.goal;
    // get type of puzzle to run and its associated library
    // currently, onlt the eight puzzle is supported.
    if (puzzleType === 'eightPuzzle') {
        puzzle =  eightPuzzle;
    }
    if (puzzle === '') {
        res.error = 'invalid request';
    } else {
        // get the current time before the puzzle solver is run
        startTime = new Date().getTime();
        // run the puzzle solver
        puzzleOut = puzzle.run(puzzleInfo);
        // get the current time after the puzzle is solved, calculate the total run time
        endTime = new Date().getTime();
        res.runTime = (endTime - startTime) / 1000;
        // return the results as the res object
        if (puzzleOut.solutionTree === undefined) {
            res.error = 'No solution found';
            res.solutionPath = [];
        } else {
            res.error = "";
            res.solutionPath = getSolutionPath(puzzleInfo.goal, puzzleOut.solutionTree);
            res.nodesCreated = puzzleOut.nodesCreated;
            res.nodesVisited = puzzleOut.nodesVisited;
            res.queueMax = puzzleOut.queueMax;
        }
    }
    res.input = puzzleInfo.input;
    res.algorithm = puzzleInfo.algorithm;
    return res;
};

/*
 *=======================================================================
 * getSolutionPath()
 * Input:   goal (string) - a JSON stringified version of the goal state
 *          solutionTree - the final state of the solutionTree
 * Output: (Array) - an array containing a series of objects that contain
 *                  the state and move to make in each step of the solution.
 *                  This array is used by the UI to print the solution and
 *                  allow the user to step through each state visually
 *=======================================================================
 */
var getSolutionPath = function (goal, solutionTree) {
    "use strict";
    var solutionPath, currentNode;
    solutionPath = [];
    currentNode = goal;
    // Add the goal node to the array
    solutionPath.push({node: goal, whatChild: solutionTree[goal].whatChildIsThis});
    // starting at the goal node, find the parent of the current node, and add it to the array,
    // continue adding parent nodes until the root node is reached.
    while (solutionTree[currentNode].parent !== 'root') {
        currentNode = solutionTree[currentNode].parent;
        solutionPath.push({ node: currentNode, whatChild: solutionTree[currentNode].whatChildIsThis });
    }
    return solutionPath;
};